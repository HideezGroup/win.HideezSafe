using Hideez.SDK.Communication.Log;
using HideezClient.Messages;
using HideezClient.Utilities;
using HideezMiddleware.IPC.Messages;
using HideezMiddleware.Utils.WorkstationHelper;
using Meta.Lib.Modules.PubSub;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using WindowsInput;

namespace HideezClient.Modules.WorkstationManager
{
    class WorkstationManager : Logger, IWorkstationManager
    {
        readonly IInputSimulator inputSimulator = new InputSimulator();
        readonly BleDeviceUnpairHelper.BleDeviceUnpairHelper _bleDeviceUnpairHelper;

        public WorkstationManager(IMetaPubSub metaMessenger, ILog log)
            : base(nameof(WorkstationManager), log)
        {
            _bleDeviceUnpairHelper = new BleDeviceUnpairHelper.BleDeviceUnpairHelper(metaMessenger, log);

            // Start listening command messages
            metaMessenger.TrySubscribeOnServer<LockWorkstationMessage>(LockPC);
            //metaMessenger.Subscribe<ForceShutdownMessage>(ForceShutdown);
            metaMessenger.TrySubscribeOnServer<ActivateScreenRequestMessage>(ActivateScreen);
        }

        public void LockPC()
        {
            WriteLine($"Calling Win32.LockWorkstation");
            var result = Win32Helper.LockWorkStation();
            WriteLine($"Win32.LockWorkstation result: {result}");
            if (result == false)
            {
                throw new Win32Exception(Marshal.GetLastWin32Error());
            }
        }

        public void ForceShutdown()
        {
            var process = new ProcessStartInfo("shutdown", "/s /f /t 0")
            {
                CreateNoWindow = true,
                UseShellExecute = false
            };
            Process.Start(process);
        }

        public void ActivateScreen()
        {
            var lockState = WorkstationInformationHelper.GetCurrentSessionLockState();
            if (lockState == WorkstationInformationHelper.LockState.Locked ||
                lockState == WorkstationInformationHelper.LockState.Unknown)
            {
                try
                {
                    // Should trigger activation of the screen in credential provider with zero impact on user
                    //inputSimulator.Keyboard.KeyPress(WindowsInput.Native.VirtualKeyCode.F12);
                    inputSimulator.Mouse.RightButtonClick(); // Windows 10 lockui ignores right mouse button for controls interaction
                }
                catch (Exception ex)
                {
                    // The exception generated by library uses generic Exception class
                    if (ex.Message.StartsWith("Some simulated input commands were not sent successfully"))
                    {
                        // This exception is thrown when the library could not successfully send simulated input
                        // To the target window, usually due to User Interface Privacy Isolation (UIPI)
                        WriteLine("UIPI prevented simulated input", LogErrorSeverity.Warning);
                    }
                    else
                        throw;
                }
            }
        }

        #region Messages handlers

        private Task LockPC(HideezMiddleware.IPC.Messages.LockWorkstationMessage command)
        {
            try
            {
                LockPC();
            }
            catch (Exception ex)
            {
                WriteLine(ex);
            }

            return Task.CompletedTask;
        }

        private void ForceShutdown(ForceShutdownMessage command)
        {
            try
            {
                ForceShutdown();
            }
            catch (Exception ex)
            {
                WriteLine(ex);
            }
        }

        private Task ActivateScreen(ActivateScreenRequestMessage message)
        {
            try
            {
                ActivateScreen();
            }
            catch (Exception ex)
            {
                WriteLine(ex);
            }

            return Task.CompletedTask;
        }
        #endregion Messages handlers
    }
}
